//------------------------------------------------------------------------------------------------------------------------------------------
void Merge(int A[],int L1,int R1,int L2,int R2){
    int temp[maxn],i=L1,j=L2,index=0;
    while(i<R1&&j<R2){
        if(A[i]<=A[j])
            temp[index++]=A[i++];
        else
            temp[index++]=A[j++];
    }
    while(i<R1)temp[index++]=A[i++];
    while(j<R2)temp[index++]=A[j++];
    for(i=0;i<index;i++)
        A[L1+i]=temp[i];
}

//递归写法：分到最小的区间在开始merge
void MergeSort(int A[],int left,int right){
    if(left<right){
        int mid=((right-left)>>1)+left;
        MergeSort(A, left, mid);
        MergeSort(A, mid+1, right);
        //divide ntil the minimum
        Merge(A, left, mid, mid+1, right);
    }
}

//迭代算法：步长为2开始递增，内层循环对每小组内容排序，找到右端点和区间长度的最小值作为merge的右端点
void MergeSort2(int A[],int n){
    for(int step=2;step<=n;step<<=1)
        for(int i=1;i<=n;i+=step){
            int mid=i+step-1;
            if(mid+1<=n)
                Merge(A, i, mid, mid+1, fmin(i+step-1,n));
        }
}
